```{python}
import numpy as np

import plotly as pl
import plotly.graph_objs as go
from plotly.subplots import make_subplots
```

## the Chen Feng Palomar model 

This document present a rudimentary python implementation of the Chen-Feng-Palomar model.

Given a day indexed by $t\in T$ and an intraday observation indexed by $i\in I$, we define the time index $\tau\equiv t\times i$. The cfp model is specified by the following system:

$$
\begin{aligned}
y_\tau &= c \cdot x_\tau + \epsilon_\tau \\
x_{\tau+1} &= A_\tau x_\tau + \phi_\tau + \gamma_\tau
\end{aligned}
$$
with $\epsilon_\tau\sim \mathcal N(0, Q_\tau)$ and $\gamma_\tau\sim\mathcal N(0, r)$. We also have the following specifications: 
- $c = [1 \ 1]$.
- The matrix $A_\tau$ is such that:
$$
\begin{aligned}
A_\tau & = \left[
\begin{array}{cc}
a_\eta& 0\\
0 & a_\mu
\end{array}
\right]\text{, for $\tau$ such that $i = 1$}\\
A_\tau & = \left[
\begin{array}{cc}
1 & 0\\
0 & a_\mu
\end{array}
\right]\text{, for $\tau$ such that $i \neq 1$}\\
\end{aligned}
$$
- The matrix $Q_\tau$ is such that 
$$
\begin{aligned}
Q_\tau & = \left[
\begin{array}{cc}
s_\eta& 0\\
0 & s_\mu
\end{array}
\right]\text{, for $\tau$ such that $i = 1$}\\
Q_\tau & = \left[
\begin{array}{cc}
0 & 0\\
0 & s_\mu
\end{array}
\right]\text{, for $\tau$ such that $i \neq 1$}\\
\end{aligned}
$$

```{python}
class parameters:
    def __init__(self, a_eta, a_mu, s_eta, s_mu, r, pi, sigma, phi):
        self.a_eta = a_eta
        self.a_mu = a_mu
        self.s_eta = s_eta
        self.s_mu = s_mu
        self.r = r
        self.pi = pi
        self.sigma = sigma
        self.phi = phi
        
    @property
    def a_0(self):
        return np.array([[self.a_eta, 0.0], [0.0, self.a_mu]])
    
    @property
    def a_1(self):
        return np.array([[1.0, 0.0], [0.0, self.a_mu]])
    
    @property
    def q_0(self):
        return np.array([[self.s_eta, 0.0], [0.0, self.s_mu]])
    
    @property
    def q_1(self):
        return np.array([[0.0, 0.0], [0.0, self.s_mu]])
```

```{python}
class model:
    def __init__(self, params):
        self.params = params
        
    def simulate(self, ndays, seed=None, debug=False):
        np.random.seed(seed)
        T = len(self.params.phi) * ndays
        res = np.zeros(T)
        
        a_0 = self.params.a_0
        a_1 = self.params.a_1
        q_0 = self.params.q_0
        q_1 = self.params.q_1
        
        s1 = np.array([[self.params.sigma[0], 0.0], [0.0, self.params.sigma[1]]])
        x = np.random.multivariate_normal(self.params.pi, s1)
        c = np.array([1.0, 1.0]).reshape((1, 2))

        for tau in range(0, T):
            t = tau % len(self.params.phi)
                
            if t == 0:
                x = a_0 @ x + np.random.multivariate_normal([0.0, 0.0], q_0)
            else:
                x = a_1 @ x + np.random.multivariate_normal([0.0, 0.0], q_1)

            res[tau] = c @ x + self.params.phi[t] + np.random.normal(0.0, self.params.r)
            
        return res
        
```

```{python}
# scaling variance
var = 1e-2

p = parameters(
          a_eta = 0.3
        , a_mu  = 0.9
        , s_eta = 0.1 * var
        , s_mu  = 0.3 * var
        , r     = var
        , pi    = [0.0, 0.0]
        , sigma = [0.1 * var, 0.1 * var]
        , phi   = [1.0, 0.4, 0.5, 0.6, 0.8]
)

m = model(p)
```

### 1. simulate according to a given model dynamic

```{python}
ndays = 10
nsims = 40
sims = [m.simulate(ndays, seed=None) for n in range(0, nsims)]

avg = np.mean(sims, axis=0)
std = np.std(sims, axis=0)
stdp = avg + 2 * std
stdm = avg - 2 * std
```

```{python}
fig = make_subplots(rows=1, cols=1)
fig.add_trace(go.Scatter(y=stdm, line=dict(color='green'), fillcolor='rgba(26,150,65,0.5)'), row = 1, col = 1)
fig.add_trace(go.Scatter(y=stdp, line=dict(color='green'), fill='tonexty'), row = 1, col = 1)
fig = fig.add_trace(go.Scatter(y=sims[0], name='data'), row = 1, col = 1)
fig.update_layout(showlegend=False)
fig
```

### 2. compute the kalman filter/smoother of the time series

```{python}
def filter(self, y, debug=False):
    
    T = len(self.params.phi)

    # initial cmean ccov values
    cmean = np.array(self.params.pi).reshape((2, 1))
    
    # initial pmean pcov values
    ccov = np.array([[self.params.sigma[0], 0.0], [0.0, self.params.sigma[1]]]).reshape((2, 2))
    
    c = np.array([1.0, 1.0]).reshape((1, 2))
    rv = np.zeros(len(y))
    
    for t in range(0, len(y)):

        # new day ?
        if t % T == 0:
            amat = self.params.a_0
            qmat = self.params.a_1
        else:
            amat = self.params.q_0
            qmat = self.params.q_1

        pmean = amat @ cmean
        pcov  = amat @ ccov @ np.transpose(amat) + qmat
        kgain = pcov @ np.transpose(c) / (c @ pcov @ np.transpose(c) + self.params.r)
        tt = kgain * (y[t] - self.params.phi[t % T] - c @ pmean)
        cmean = pmean + kgain * (y[t] - self.params.phi[t % T] - c @ pmean)
        ccov  = pcov - kgain @ c @ pcov
        
        # the filtered signal
        
        rv[t] = c @ pmean + self.params.phi[t % T]
    return rv

setattr(model, 'filter', filter)
```

```{python}
flts = [m.filter(s) for s in sims]
```

```{python}
fig = make_subplots(rows=1, cols=1)
fig.add_trace(go.Scatter(y=flts[0], name = 'filter'), row = 1, col = 1)
fig.add_trace(go.Scatter(y=sims[0], name = 'data'), row = 1, col = 1)
fig.update_layout(showlegend=True)
fig
```

```{python}

# dummy
model = otos.cfp.model(p)
fit = model.emax(data, 10000, 1e-15)
```

# plot 

```{python}

import plotly, json
import plotly.graph_objects as go
from plotly.subplots import make_subplots

pl = make_subplots(rows = 1, cols = 1, shared_xaxes=True)

pl = pl.add_trace(go.Scattergl(y = data, name = 'simulation'
    ), row=1, col=1)
pl = pl.add_trace(go.Scattergl(y = flt, name = 'filter'
    ), row=1, col=1)
pl = pl.add_trace(go.Scattergl(y = smt, name = 'smoother'
    ), row=1, col=1)
    
plotly.io.write_html(pl, file='cfp_fig1.html', auto_open=False)
```

```{r echo=FALSE}
htmltools::includeHTML("cfp_fig1.html")
```

```{python}

np.random.seed(1234)

p = otos.cfp.parameters()
p.a_eta = 0.93970117964
p.a_mu  = 0.617656427391
p.s_eta = 0.00611157182105
p.s_mu  = 0.100157446738
p.pi    = [-0.0377453676475, 0.637412180444]
p.sigma = [9.49012643982e-05, 0.00182247858807]
p.r     = 0.0670554645138
p.psi   = [ 
           15.3322974898, 14.8914481022, 14.8960953411
         , 14.7328251327, 14.717101214 , 14.600429107 , 14.5878141379
         , 14.51710026  , 14.4863107795, 14.381950856 , 14.3423713871
         , 14.2429064605, 14.2109154215, 14.1635064751, 14.2339929961
         , 14.1522787054, 14.1947867672, 14.1869497863, 14.4385168913
         , 14.3792550185, 14.4077635371, 14.4649051166, 14.624926768
         , 14.7170306255, 15.0749366985, 15.9959231225 
        ]

md = otos.cfp.model(p)
df = dt.Frame(sim=otos.cfp.simulate(p, size=1000))
df = df[:, f[:].extend({'foo': md.predict(df[:, 'sim'], 10)})]
```
